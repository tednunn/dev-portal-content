This is Part I of a series of 3 tutorials:

[Part I](https://developers.iotex.io/posts/Walk-to-Earn-Workshop-Part-1) | [Part II](https://developers.iotex.io/posts/Walk-to-Earn-Workshop-Part-2) | [Part III](https://developers.iotex.io/posts/Walk-to-Earn-Workshop-Part-3)

**MachineFi** is a methodology designed by IoTeX that allows the creation of decentralized financial applications based on data generated by any device in the real world.
During this workshop you'll learn the principles of MachineFi, from trusted data and trusted devices, to IoT token economies, data privacy and storage. You will also learn how to build a working MachineFi application with a simple token economy, including the device programming.

In this workshop we will build MachineFi application that rewards users with crypto-assets for doing health-related activities in the real world. Specifically, we will design a device that acts as a step counter that accumulates the total number of steps walked by the user and sends this information periodically to a computational blockchain oracle. This is basically a decentralized network that IoTeX is building that plays a critical role in the design of MachineFi applications: it is a programmable network that can be used to:
1. Receive data from devices
2. Use blockchain to Authorize the devices and verify the data
3. Process/filter or do any IoT-related computation on the data
4. Store the data (with multiple storage options, centralized or decentralized)
5. Generate cryptography "Proofs of anything" (proofs of facts and events that happened in the real-world based on the data)
6. Serve these proof to blockchain smart-contracts that need them

The workshop is split into 3 parts:

**In Part I**, we'll view all the components of the project, how it works, and what the limitations are, and I will focus on hardware programming.

**In Part II**, we go into the smart contracts details of this MachineFi App, describe them one by one, and deploy them to the IoTeX Testnet, to have the Blockchain side of the project ready.

**In Part III**, we'll learn about  W3bstream: the IoTeX real-world data computational oracle, how it receives data from devices, data verification, storage and proof generation.

# Project overview
Let's call our MachineFi app "*WalkToEarn*". WalkToEarn is based on a **steps counter device**, a blockchain Dapp that uses an ERC20 token to reward users and a simple "Walk-to-Earn" token economy contract (that rewards users the more they walk), and of course, a blockchain oracle that takes care of IoT data off-chain, and also uses a few smart contracts on the Blockchain to authorize devices when data arrives, and generate the "Proofs of walking" that are needed by the token economy contract.

# How does it work?
The step counter is a device that counts the number of steps when you carry it with you while walking. It just keeps accumulating the total number of steps, forever. Much like the odometer in a car, that keeps counting miles starting from zero, and forever. When first started it will count "0" steps, and the more you walk the more steps it adds up to the total. If you shut down the device, of course, it will not count but when you power it on again it will start from the last stored total value.
When the user does not walk, the device does nothing, but when the user walks , it keeps sending the current total number of steps to the blockchain oracle along with the timestamp, every 5 seconds (this could be improved, of course - e.g. by managing connection errors, last successfully sent data etc). This data is enough...

On the **Oracle** side, we receive these data messages `{ timestamp, totalSteps}` and we just store them in a local database on the oracle server.  We may implement some IoT logic here. For example, ignoring "short walks", or incentivize group walking if we have GPS data, but we'll make it easy and just reward all steps (feel free to improve the project!). 

The oracle is made by an off-chain component (the oracle layer-2 network) but also by a blockchain component: in fact it uses 2 contracts:

A **device registry contract** that stores the unique ids of all the step counters, and the oracle uses this contract to make sure the data that it receives is actually coming from one our devices and not say from a fake device or even a software simulator this means we have pre-registered the ids of our devices to this contract). 

We also have a **device binding contract** that binds each device to the blockchain wallet of the device owner. We need it because we do not reward the devices, we reward the owner 's wallet and typically a user can own multiple devices. So typically, when a user claims her rewards, the contract would need to know all the walking activity she did with any of her devices. 
Finally, we have the actual token economy contracts, the Dapp. Of course, we have an ERC20 token that we use to send rewards to the users, and we have a "walk to earn" contract that users interact with to claim their rewards. 

# The workflow:
1. The user "buy"s the step counter, which is bound to his wallet account by the manufacturer upon proof of ownership
2. The user does some walking activity, say he walks 10000 steps in 24 hours, which generates multiple messages (one every 5 seconds) from the device to the Iot oracle
3. The user opens the Dapp frontend and interacts with the WalkToEarn smart contract by "Claiming" his rewards
4. The smart contract will first make sure that the user does actually own one devices, then it emits an event that logs the request (device id, owner address, from when to when). 
5. The Oracle will detect the event and extract the request data from it, extract all steps data for that device in the requested timeframe, calculate the total number of steps and send it to the smart contract that will "credit" those steps to the user according to some incentive rule (e.g. 1 token per step).
6. Finally, the user can "Withdraw" his balance from the smart contract at any time.

# The device
As a step counter, I will use an Arduino Nano 33 IoT board, because it's cheap, it integrates a secure element to make the device and its data verifiable according to the MachineFi methodology, and it integrated an accelerometer with a step-counting feature.
Pros: Secure element, integrated IMU, WiFi, cheap choice for building a PoC
Cons: poor set of integrated sensors, no GPS, no IoT cellular modem
Firmware explanation

I used the **pedometer functionality** integrated into the IMU. It counts the number of steps based only on the acceleration measured on the Z axis. But Every time the board is reset, the pedometer starts counting from 0 again. So, I store the current total number of steps in the flash. On every boot, the total steps counter variable is initialized with the last value stored in flash, and new steps get added from the IMU on top of it. So the device is just counting all steps, forever.

The integrated steps counter on the Nano 33 IoT board is not great: you can setup some acceleration thresholds to detect the steps, but there is no AI into the recognition of a step, so it's a bit limited. Also, it has only wifi, so in theory we should use the mobile phone to give it access to the internet. Better hardware should be used that includes cellular connection or at least low power bluetooth, and a GPS.  

Here is the full code of the Arduino board firmware (I'll only focus on the more relevant functions, the rest are just utility functions):

```cpp
[ ... ]
// Configure your Wifi and MQTT endpoint
#include "secrets.h"

// Send messages with the MQTT protocol
#include <ArduinoMqttClient.h>

// Use accelerometer as a pedometer
#include <SparkFunLSM6DS3.h>
#include "Wire.h"
#include "SPI.h"

// Use the integrated secure crypto chip
#include <ArduinoECCX08.h>

[...]

void setup() {
  ...

  Serial.println("Initialize the pedometer...");
  if (!setupIMU()) {
    ...
  }

  Serial.print("Read total steps from flash...");
  steps = steps_storage.read();
  Serial.println(steps); 
  
  Serial.println("Initialize the secure crypto chip...");
  if (!ECCX08.begin()) {
    ..
  }

  // Verify the crypto chip is locked (ie. configured.).
  if (!ECCX08.locked()) {
    ...
  }

  // Connect to WiFi
  initWiFi();

  // Sync with Internet time 
  timeClient.begin();
  timeClient.update();
  ...

  // Connect to the MQTT Broker
  if (!initMqtt()) {
    ...
  }

  // Retrieve the public key from the secure crypto chip.
  ECCX08.generatePublicKey(slot, publicKey);
  String pubKey = BufferHexToStr(publicKey, sizeof(publicKey));
  Serial.print("Device's public key: " + pubKey);
  
  topic = "/device/" + pubKey + "/data";
  Serial.print("MQTT Topic: " + topic);
}

void loop() {
  // Wait for the accelerometer to accumulate steps 
  // ! not efficient, we should use deep sleep and wake up 
  while (!readSteps()) { 
     delay(3000);
  };

  readSteps();

  // Build a message using data from the accelerometer.
  Serial.println("\n---- NEW MESSAGE ----");
  
  // Get internet timestamp
  String timestamp = String(timeClient.getEpochTime()); 
  // Build the data message { "steps": "123", "timestamp": "12345678" }
  String message = buildMessage(steps, timestamp);

  // Hash the message using sha256.
  byte hash[32] = {0};
  ECCX08.beginSHA256();
  ECCX08.endSHA256((byte*)message.c_str(), message.length(), hash);
  Serial.println("Message hash is: "+ BufferHexToStr(hash, sizeof(hash)));

  // Sign the message.
  byte signature[64];
  ECCX08.ecSign(slot, hash, signature);
  Serial.println("Signature is " + BufferHexToStr(signature, sizeof(signature)));

  // Build the full message including digital signature
  String mqttMessage = buildSignedMessage(message, signature, sizeof(signature));
  // Sending the message over MQTT protocol
  Serial.print("Sending mqtt message: ");
  Serial.println(mqttMessage);
  mqttClient.beginMessage(topic);
  mqttClient.print(mqttMessage);
  mqttClient.endMessage();

  delay(3000);
  }
  
  ...
````

So the firmware works like this: 
1. On boot, it will do initialization and read the last stored number of steps
2. In Loop, it will wait for the IMU to accumulate new steps
3. Read the total number of steps in the IMU and add up to the total steps
4. Save the new value of total steps in flash
5. Build the data JSON object
6. Use the secure crypto chip to sign the data object
7. Create the final message with data, signature and some more useful info
8. Send the message over to the W3bstream oracle using the MQTT protocol

# Flashing the firmware
The full firmware can be found here: 

https://github.com/simonerom/walk-to-earn-arduino/tree/main/devices/Arduino

just copy the folder under your Arduino source code folder and edit `secrets.h` to suit your network configuration. 
At this point, we can go ahead and add our wifi passwords in secrets.h, configure the W3bstream endpoint with the W3bstream node ip address and use Arduino IDE to flash the firmware.

After flashing is done, we can open the Arduino Serial monitor and the output log should look like this:

```
::::: APP STARTED :::::......
Verifiable pedometer with Arduino nano 33 IoT
Initialize the pedometerr...
IMU OK
Read total steps from flash...0
Initialize the secure chip...
Connecting to wifi: TIM-87716465
Connecting to WiFi ..
Connected. IP: 
192.168.1.114
Syncing time...12:01:29- 1663243289
Connecting to the MQTT broker on 167.235.27.38:1883MQTT connection failed! Error code = -2
Failed to connect to the MQTT broker.
```

Basically, the board succeded initializing everything, but it's failing to connect to the data oracle node, since we have not configured it yet.

*In part II we will describe the token economy of the *WalkToEarn* app and deploy the contracts on the IoTeX Testnet chain.* 


# Limitations
Let's spend a few words on what are the limitations of this design that prevent it from being used in production:

1. Poor power management (deep sleep and wake-up on IMU data should be used)
2. Firmware is not tamper proof (we should implement secure boot)
3. Total number of steps is not tamper proof (the steps should be stored along with its signature made with the secure element (so that only the firmware can actually store that value, because no-one knows the private key of the secure chip, and the firmware should also be tamper proof) 
4. Unbound devices should not be allowed to send data: this could be checked by the device itself by reading the deviceBinding smart contract and making sure it's bound to an owner before beginning the loop, to save power and bandwidth if it's a cellular based device. But anyway, the W3bstream node should reject data incoming from unbound devices.
5. Data can be replayed: the device should have a nonce associated and it should be included in the data message, while W3bstream should keep track of the current nonce for each device and reject messages with invalid nonces.
6. Steps can be easily faked with the IMU steps function. A GPS should be associated with the device,and possibly AI should be used on all three axes of the accelerometer (but this is not possible on the Nano 33 IoT)
